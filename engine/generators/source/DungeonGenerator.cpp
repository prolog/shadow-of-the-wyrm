#include "DungeonGenerator.hpp"
#include "AllTiles.hpp"
#include "TileGenerator.hpp"
#include "RNG.hpp"

using namespace std;

DungeonGenerator::DungeonGenerator()
: DEFAULT_MIN_HEIGHT(3)
, DEFAULT_MAX_HEIGHT(8)
, DEFAULT_MIN_WIDTH(3)
, DEFAULT_MAX_WIDTH(8)
, SPACE_BETWEEN_FEATURES(2)
{
  initialize_height_and_width_maps();
}

void DungeonGenerator::initialize_height_and_width_maps()
{
  // Min/Max Heights
  feature_height_map.insert(make_pair(DUNGEON_FEATURE_ROOM, make_pair(DEFAULT_MIN_HEIGHT, DEFAULT_MAX_HEIGHT)));

  // Min/Max Widths
  feature_width_map.insert(make_pair(DUNGEON_FEATURE_ROOM, make_pair(DEFAULT_MIN_WIDTH, DEFAULT_MAX_WIDTH)));
}

MapPtr DungeonGenerator::generate(const Dimensions& dimensions, const std::string& map_exit_id)
{
  MapPtr result_map = MapPtr(new Map(dimensions));

  fill(result_map, TILE_TYPE_ROCK);
  result_map = generate_dungeon(result_map);
  
  result_map->set_map_type(MAP_TYPE_UNDERWORLD);

  return result_map;
}

TilePtr DungeonGenerator::generate_tile(MapPtr current_map, const int row, const int col)
{
  TilePtr result_tile;
  return result_tile;
}

/*
 * Dungeons are generated by:
 *
 * 1. Dig a feature (initially in the top-left corner).
 * 2. Attempt to dig between 1 and 4 corridors and attach a feature:
 * 3. Check to see if the corridor and feature can be dug.  If the corridor can't be
 *    dug, try again at a different place along the wall.
 * 4. Dig the corridor and feature
 * 5. Repeat steps 1 through 4 until no more features can be added.
 *
 */
MapPtr DungeonGenerator::generate_dungeon(MapPtr map)
{
  MapPtr result_map = MapPtr(new Map(*map));
  bool more_features_can_be_added = true;

  // FIXME START REFACTOR
  // Attempt to add a room
  int start_y = RNG::range(1, 2);
  int start_x = RNG::range(1, 2);
  DungeonFeature feature_type = get_random_feature();
  int height = RNG::range(get_min_feature_height(feature_type), get_max_feature_height(feature_type));
  int width  = RNG::range(get_min_feature_width(feature_type), get_max_feature_width(feature_type));
  place_feature(result_map, feature_type, start_y, start_x, height, width);

  // FIXME END REFACTOR

  while(more_features_can_be_added)
  {

  }

  // while(more_features_can_be_added)
  // {
  //   create_feature(...);
  //
  // }

  place_staircases(result_map);

  return result_map;
}

void DungeonGenerator::place_feature(MapPtr map, const DungeonFeature feature, int start_row, int start_col, int size_rows, int size_cols)
{
  switch(feature)
  {
    // Update this later.
    case DUNGEON_FEATURE_ROOM:
    case DUNGEON_FEATURE_CIRCULAR_WITH_PIT:
    case DUNGEON_FEATURE_CAVE_IN:
    case DUNGEON_FEATURE_VAULT:
    case DUNGEON_FEATURE_OUT_OF_DEPTH_VAULT:
    case DUNGEON_FEATURE_BEEHIVE:
    case DUNGEON_FEATURE_ZOO:
      place_room(map, start_row, start_col, size_rows, size_cols);
      break;
    default:
      break;
  }
}

void DungeonGenerator::place_room(MapPtr map, int start_row, int start_col, int size_rows, int size_cols)
{
  int size_y = start_row + size_rows;
  int size_x = start_col + size_cols;
  for (int y = start_row; y < size_y; y++)
  {
    for (int x = start_col; x < size_x; x++)
    {
      TilePtr tile = TileGenerator::generate(TILE_TYPE_DUNGEON);
      map->insert(y, x, tile);
    }
  }
}

void DungeonGenerator::place_doorway(MapPtr map, int row, int col)
{

}

void DungeonGenerator::place_staircases(MapPtr map)
{
}

// Eventually, this needs to be updated to get features based on danger level, as well.
DungeonFeature DungeonGenerator::get_random_feature()
{
//  DungeonFeature feature = static_cast<DungeonFeature>(RNG::range(DUNGEON_FEATURE_MIN, DUNGEON_FEATURE_MAX));
  return DUNGEON_FEATURE_ROOM;
}

int DungeonGenerator::get_min_feature_height(const DungeonFeature feature)
{
  DungeonFeatureSizeMapIterator_const h_it = feature_height_map.find(feature);

  if (h_it != feature_height_map.end())
  {
    return h_it->second.first;
  }

  return DEFAULT_MIN_HEIGHT;
}

int DungeonGenerator::get_max_feature_height(const DungeonFeature feature)
{
  DungeonFeatureSizeMapIterator_const h_it = feature_height_map.find(feature);

  if (h_it != feature_height_map.end())
  {
    return h_it->second.second;
  }

  return DEFAULT_MAX_HEIGHT;
}

int DungeonGenerator::get_min_feature_width(const DungeonFeature feature)
{
  DungeonFeatureSizeMapIterator_const w_it = feature_width_map.find(feature);

  if (w_it != feature_width_map.end())
  {
    return w_it->second.first;
  }

  return DEFAULT_MIN_WIDTH;
}

int DungeonGenerator::get_max_feature_width(const DungeonFeature feature)
{
  DungeonFeatureSizeMapIterator_const w_it = feature_width_map.find(feature);

  if (w_it != feature_width_map.end())
  {
    return w_it->second.second;
  }

  return DEFAULT_MAX_WIDTH;
}
